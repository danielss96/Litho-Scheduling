from docplex.mp.model import Model
from docplex.mp.progress import *
from docplex.cp.model import *
import docplex.cp.utils_visu as visu
from pylab import rcParams
import time


def solve_master_problem(items, reticles, machines, periods, D, PT, PC, IC, BC, Req, B, overtime):

    # Create and setup model
    master = Model()
    master.add_progress_listener(TextProgressListener())

    master.set_time_limit(10)

    # Decision Variables
    x = {(i, m, r, t): master.binary_var(name="X_{0}_{1}_{2}_{3}".format(i, m, r, t)) for i in items
         for m in machines for r in reticles for t in periods}
    z = {(i, m, t): master.integer_var(name="Z_{0}_{1}_{2}".format(i, m, t)) for i in items for m in machines
         for t in periods}
    q = {(i, t): master.integer_var(name="I_{0}_{1}".format(i, t)) for i in items for t in periods}
    u = {(i, t): master.integer_var(name="U_{0}_{1}".format(i, t)) for i in items for t in periods}

    # Decision Expression
    setup_cost = master.sum(x[i, m, r, t] * PC[i] for i in items for t in periods for m in machines for r in reticles)
    inventory_cost = master.sum(q[i, t] * IC[i] for i in items for t in periods)
    backlog_cost = master.sum(u[i, t] * BC[i] for i in items for t in periods)
    total_cost = setup_cost + inventory_cost + backlog_cost

    # Objective
    master.minimize(total_cost)

    for i in items:
        for t in periods:
            if t == 0:
                master.add_constraint(master.sum(z[i, m, t] for m in machines) + u[i, t] == D[i][t] + q[i, t])
            else:
                master.add_constraint(
                    q[i, t - 1] + master.sum(z[i, m, t] for m in machines) + u[i, t] == D[i][t] + q[i, t]
                    + u[i, t - 1])

    for i in items:
        for m in machines:
            for t in periods:
                master.add_constraint(0 >= z[i, m, t] - B * master.sum(x[i, m, r, t] for r in reticles))

    for m in machines:
        for t in periods:
            for i1 in items:
                for i2 in items:
                    if i1 != i2:
                        master.add_constraint(master.sum(z[i, m, t] * PT[i] for i in items)
                                              + (sum(x[i1, m, r, t] + x[i2, m, r, t] for r in reticles) - 1) * 10
                                              + overtime[m][t] <= L)

    for i in items:
        for r in reticles:
            for m in machines:
                for t in periods:
                    if r not in Req[i]:
                        master.add_constraint(x[i, m, r, t] <= 0, ctname="Ensures reticle compatibility")

    # Solve Model
    solution = master.solve()

    # Print Solution Costs
    if solution:
        print("Total Cost: ", solution.objective_value)
        print("Setup Costs: ", solution.get_value(setup_cost))
        print("Inventory Costs: ", solution.get_value(inventory_cost))
        print("Backlog Costs: ", solution.get_value(backlog_cost))

        # Print the solution values for x
        print("Solution values for x:")
        for (i, m, r, t), var in x.items():
            print(f"x[{i}, {m}, {r}, {t}] = {solution.get_value(var)}")

        # Print the solution values for z
        print("\nSolution values for z:")
        for (i, m, t), var in z.items():
            print(f"z[{i}, {m}, {t}] = {solution.get_value(var)}")

    else:
        print("No solution found")

    return solution, x, z

def solve_cp_model(master_solution, x, z, items, reticles, machines, periods, PT, setup_matrix, transport_matrix):

    if master_solution is None:
        print("No master solution available to solve the CP model.")
        return

    # Create CP Model
    cp = CpoModel()
    inf_counter = 0

    # Define Interval Variable
    lot = {}
    for i in items:
        for m in machines:
            for t in periods:
                for r in reticles:
                    lot[(i, m, r, t)] = interval_var(optional=True, name="Lot_{}_{}_{}_{}".format(i, m, r, t))

    # Define Sequence Variable for the machines
    stepper = {m: sequence_var([lot[(i, m, r, t)] for i in items for r in reticles for t in periods],
                               types=[r for r in reticles for i in items for t in periods],
                               name="S_{}".format(m)) for m in machines}

    # Define Sequence Variable for the reticles
    reticle = {r: sequence_var([lot[(i, m, r, t)] for i in items for m in machines for t in periods],
                               types=[m for m in machines for t in periods for r in reticles],
                               name="R_{}".format(r)) for r in reticles}

    # Objective Value
    makespan = {t: integer_var(name="I_{0}".format(t)) for t in periods}
    period_makespan = sum(makespan[t] for t in periods)
    cp.minimize(period_makespan)

    # Constraints
    for i in items:
        for m in machines:
            for t in periods:
                for r in reticles:
                    # Calculates the makespan of each period
                    cp.add(end_of(lot[i, m, r, t]) <= makespan[t])

                    # Ensures the precense of the interval variable if is x = 1 (master Problem)
                    cp.add(presence_of(lot[i, m, r, t]) == master_solution.get_var_value(x[i, m, r, t]))

                    # Ensures the interval varaible takes place on its corresponding period
                    cp.add(start_of(lot[i, m, r, t]) >= L * t * master_solution.get_var_value(x[i, m, r, t]))

                    # Computes the lenght of the interval variable based on the lot-size (master Problem)
                    cp.add(length_of(lot[i, m, r, t]) == PT[i] * master_solution.get_var_value(z[i, m, t])
                           * master_solution.get_var_value(x[i, m, r, t]))

    # No Overlap for machines and setup matrix
    for m in machines:
        cp.add(no_overlap(stepper[m], setup_matrix, is_direct=True))

    # No overlap for reticles and transport matrix
    for r in reticles:
        cp.add(no_overlap(reticle[r], transport_matrix, is_direct=True))

    # Solve Model
    cp_solution = cp.solve()

    # If a solution exists: Checks for makespan violations (i.e. makespan > L) in each period
    if cp_solution:
        for (t), var in makespan.items():
            print(f"makespan[{t}] = {cp_solution.get_value(var)}")
            if cp_solution.get_value(var) > L + L * t:
                print("cut is needed\n")
                inf_counter += 1

        # If a violations exist:
        # Identify the machine and period where it occurs, and the size of it.
        # Add to the overtime list (further used in the MP)
        if inf_counter > 0:
            for i in items:
                for m in machines:
                    for t in periods:
                        for r in reticles:
                            lot_var = lot[(i, m, r, t)]
                            if cp_solution.get_var_solution(lot_var).is_present():
                                endtime = cp_solution.get_var_solution(lot_var).get_end()
                                if endtime > L * (1 + t):
                                    violation = endtime - L * (1 + t)
                                    overtime[m][t] += violation

        # If no violations occured:
        else:

            # Print final makespan solution
            total_makespan = max(cp_solution.get_value(makespan[t]) for t in periods)
            print("Total Makespan:", total_makespan, "\n")

            # Set Gantt parameters
            rcParams['figure.figsize'] = 8, 4
            visu.timeline('Solution for Lot Sizing Problem')
            visu.panel('Machines')

            # Get name of Items
            product = dict()
            for m in machines:
                for i in items:
                    for r in reticles:
                        for t in periods:
                            product[lot[i, m, r, t].get_name()] = i

            # Get solution of the sequencing of interval variables
            seq = {m: [] for m in machines}
            for m in machines:
                seq[m] = cp_solution.get_var_solution(stepper[m])
                visu.sequence(name=f"Machine {m}")
                vs = seq[m].get_value()

                # Add intervals to the visulization
                for v in vs:
                    nm = v.get_name()
                    visu.interval(v, product[nm] + 1, str(product[nm] + 1))

                # Add setup transition matrix to the visulization
                for i in range(len(vs) - 1):
                    end = vs[i].get_end()
                    i1 = product[vs[i].get_name()]
                    i2 = product[vs[i + 1].get_name()]
                    visu.transition(end, end + setup_matrix[i1][i2])

            # Display Gantt
            visu.show()

            # Print solutions of the Lots
            print("\n")
            for i in items:
                for m in machines:
                    for t in periods:
                        for r in reticles:
                            lot_var = lot[(i, m, r, t)]
                            if cp_solution.get_var_solution(lot_var).is_present():
                                print(cp_solution.get_var_solution(lot_var))

    else:
        print("No solution found")

    return inf_counter


# Data
nb_items = 5
nb_reticles = 5
nb_machines = 3
nb_periods = 6
L = 240
B = L * 2

items = range(0, nb_items)
reticles = range(0, nb_reticles)
machines = range(0, nb_machines)
periods = range(0, nb_periods)

PT = [25, 30, 25, 25, 30]
PC = [20, 20, 20, 20, 20]
IC = [50, 70, 50, 50, 70]
BC = [100, 200, 100, 100, 200]

D = [
    [5, 5, 6, 4, 3, 5],
    [7, 4, 3, 5, 6, 2],
    [5, 4, 6, 4, 5, 6],
    [3, 5, 3, 4, 3, 4],
    [5, 6, 6, 4, 6, 7]
]

Req = {
    0: {0},
    1: {1},
    2: {2},
    3: {3},
    4: {4}
}

setup_matrix = [[10 if r1 != r2 else 0 for r2 in reticles] for r1 in reticles]
transport_matrix = [[5 if m1 != m2 else 0 for m2 in machines] for m1 in machines]
overtime = [[0 for t in periods] for m in machines]
iteration = 0

# Run the functions
start_time = time.time()
master_solution, x, z = solve_master_problem(items, reticles, machines, periods, D, PT, PC, IC, BC, Req, B, overtime)
sub_problem = solve_cp_model(master_solution, x, z, items, reticles, machines, periods, PT, setup_matrix, transport_matrix)

while sub_problem > 0:
    master_solution, x, z = solve_master_problem(items, reticles, machines, periods, D, PT, PC, IC, BC, Req, B,
                                                 overtime)
    sub_problem = solve_cp_model(master_solution, x, z, items, reticles, machines, periods, PT, setup_matrix,
                                 transport_matrix)
    iteration += 1

end_time = time.time()
elapsed_time = end_time - start_time

print("\n")
print("Elapsed Time:", elapsed_time)
print("Iterations:", iteration)
print("infeasibilities:", sub_problem)
